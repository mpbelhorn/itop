#!/bin/python
# -*- coding: utf-8 -*-
from __future__ import print_function
import argparse
from numpy import arange
import datetime
import itop
import os
import cPickle as pickle
import sys
import zlib

parser = argparse.ArgumentParser(description='Scan a test mirror.')
parser.add_argument('--range', dest='scan_range', nargs=2,
    metavar=('START', 'STOP'), type=float, default=[-100, -202],
    help='Specify beam input positions in mm with START < STOP')
parser.add_argument('--step', metavar='SIZE', dest='step_size', type=float,
    default=-5.0, help='Specify mirror sampling step size in mm')
parser.add_argument('--output', metavar='PATH', type=str,
    help='Path to output gz data file')
parser.add_argument('--home', action='store_true', default=False,
    help='Home the stages before taking data')
parser.add_argument('--align', action='store_true', default=False,
    help='Re-compute the tracker alignment to the beams.')

args = parser.parse_args()

profiler = itop.Profiler('/dev/ttyUSB0')
esp_300 = itop.StageController('/dev/ttyUSB1',
    limits=[250.0, [-45.0, 190.0], 125.0])
esp_301 = itop.StageController('/dev/ttyUSB2',
    limits=[125.0, [0.0, 25.0], [-95.0, 125.0]])

mirror_stage = esp_300.axes[0]
profiler_rotation_stage = esp_300.axes[1]

tracker = itop.beam.profiler.Tracker(esp_301, profiler_rotation_stage,
    profiler, home=args.home, check=True)

mirror_stage.power_on()
mirror_stage.velocity(10)
mirror_stage.home_position(-250.0)
if args.home:
  mirror_stage.go_to_home(wait=True)

alignment_path = itop.data_path('alignment/latest.gz')
if args.align:
  alignment_data = itop.beam.Alignment()
  tracker.driver.home()
  alignment_data.align(tracker, home=True)
  itop.utilities.save_object(alignment_data, alignment_path)

instrument = itop.Instrument(tracker, mirror_stage, alignment_path)
run_starting_time = datetime.datetime.utcnow().isoformat()

if args.output is None:
  args.output = itop.data_path('runs/{}-data.gz'.format(run_starting_time))

print('Starting data run at', run_starting_time, 'UTC.')
print('Mirror position')
print('===============')

for mirror_position in arange(
    args.scan_range[0], args.scan_range[1] + args.step_size, args.step_size):
  print(mirror_position)
  print(instrument.sample_position(mirror_position, proximal=True))
  instrument.save_data(args.output)

instrument.tracker.driver.home()
