#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import print_function
import argparse
import numpy as np
from numpy import arange
import datetime
import itop
import os
import cPickle as pickle
import sys
import zlib

parser = argparse.ArgumentParser(
    description='Scan an iTOP  mirror.')
parser.add_argument('--inputs', dest='input_range', nargs=2,
    metavar=('FIRST', 'LAST'), type=float, default=[-100, -202],
    help='Specify beam input positions in mm.')
parser.add_argument('--step', metavar='SIZE', dest='step_size', type=float,
    default=5.0, help='Specify mirror sampling step size in mm')
parser.add_argument('--height', metavar='HEIGHT', dest='input_y', type=float,
    default=0.0, help='Specify beam 0 input height (Jack DI) in mm')
parser.add_argument('--output', metavar='PATH', type=str,
    help='Path to output gz data file')
parser.add_argument('--home', action='store_true', default=False,
    help='Home the stages before taking data')
parser.add_argument('--align', action='store_true', default=False,
    help='Re-compute the tracker alignment to the beams.')
parser.add_argument('--alt', action='store_true', default=False,
    help='Run scan on alternate mirror.')
parser.add_argument('--tilted', action='store_true', default=False,
    help='Override out-of-range beam checks for a tilted mirror.')
parser.add_argument('--start', dest='start_point', nargs=3,
    metavar=('X', 'Y', 'Z'), type=float,
    help='Start first scan at position [X,Y,Z].')

args = parser.parse_args()

profiler = itop.Profiler(itop.INSTRUMENTS['profiler'])
esp_300 = itop.StageController(itop.INSTRUMENTS['esp 300'],
    limits=[250.0, [-45.0, 190.0], 125.0])
esp_301 = itop.StageController(itop.INSTRUMENTS['esp 301'],
    limits=[125.0, [0.0, 50.0], [-95.0, 125.0]])
beam_monitor = itop.Photodiode(itop.INSTRUMENTS['source monitor'])

mirror_axis_id = 2 if args.alt else 0
mirror_stage = esp_300.axes[mirror_axis_id]
profiler_rotation_stage = esp_300.axes[1]

tracker = itop.Tracker(esp_301, profiler_rotation_stage,
    profiler, beam_monitor, home=args.home, check=True)

mirror_stage.power_on()
if args.home or args.alt:
  mirror_stage.go_to_home(wait=True)

if args.alt:
  mirror_stage.home_position(-99.7)

alignment_path = itop.data_path('alignment/latest.gz')
if args.align or args.tilted:
  calibration = itop.data_path('alignment/latest.cfg')
  alignment_data = itop.Alignment(calibration)
  tracker.devices['driver'].home()
  alignment_data.align(tracker, home=True, tilted=args.tilted,
      mirror=mirror_stage)
  itop.utilities.save_object(alignment_data, alignment_path)

instrument = itop.Instrument(tracker, mirror_stage, alignment_path,
    args.input_y, tilted=args.tilted)
run_starting_time = datetime.datetime.now().isoformat()

if args.output is None:
  args.output = itop.data_path('runs/{}-data.gz'.format(run_starting_time))

#if not args.tilted:
#  mirror_range = instrument.alignment.mirror_limits(args.input_range)
#else:
mirror_range = [-i for i in args.input_range]
mirror_step = abs(args.step_size)
if mirror_range[1] < mirror_range[0]:
  mirror_step = -abs(args.step_size)

print(mirror_range)
print(np.append(arange(
          mirror_range[0] + mirror_step,
          mirror_range[1], mirror_step),
      mirror_range[1]))

try:
  print('Starting data run at {}.'.format(run_starting_time))
  print('===============')
  print(instrument.sample_position(
      mirror_range[0], start_point=args.start_point))
  instrument.save_data(args.output)

  for mirror_position_x in np.append(
      arange(
          mirror_range[0] + mirror_step,
          mirror_range[1], mirror_step),
      mirror_range[1]):
    print(instrument.sample_position(mirror_position_x))
    instrument.save_data(args.output)
except itop.beam.tracker.TrackerError:
  print('Reached end of stage travel.')
  instrument.save_data(args.output)
  sys.exit(1)
finally:
  print('Exiting.')
  sys.exit(0)

